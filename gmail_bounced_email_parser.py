# -*- coding: utf-8 -*-
"""gmail_bounced_email_parser

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wzNo_p2xvJYMJUBWniSMntUoZ6IREhAM
"""

!pip install google-auth #handles authentication and authorization w/google services (use credentials.json to gen valid token for API access)
!pip install google-auth-oauthlib #manages oaUTH 2.0 (open authroization url and handle callback)
!pip install google-auth-httplib2 #make authenticated HTTP requests to google APIs
!pip install google-api-python-client #client library for accessing Google APIs

import base64
import re
import pandas as pd
import time
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
import os

# Define the scopes for accessing Gmail
SCOPES = ['https://www.googleapis.com/auth/gmail.modify']

# Batch size for processing emails
BATCH_SIZE = 500

def authenticate_gmail():
    """
    Authenticate with Gmail API using a manual URL flow.
    """
    creds = None
    if os.path.exists('token.json'):
        try:
            creds = Credentials.from_authorized_user_file('token.json', SCOPES)
        except Exception:
            os.remove('token.json')
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file('credentials.json', SCOPES)
            flow.redirect_uri = 'urn:ietf:wg:oauth:2.0:oob'
            auth_url, _ = flow.authorization_url(prompt='consent')
            print(f'Please go to this URL: {auth_url}')
            code = input('Enter the authorization code: ')
            flow.fetch_token(code=code)
            creds = flow.credentials
        with open('token.json', 'w') as token:
            token.write(creds.to_json())
    return creds

def list_gmail_labels(service):
    """
    List all Gmail labels for the authenticated user.
    """
    labels = service.users().labels().list(userId='me').execute().get('labels', [])
    for label in labels:
        print(f"Label Name: {label['name']}, Label ID: {label['id']}")
    return labels

def fetch_all_messages(service, label_id, query='is:unread'):
    """
    Fetch all messages from Gmail using pagination.
    """
    all_messages = []
    try:
        # Initial API request
        response = service.users().messages().list(userId='me', labelIds=[label_id], q=query).execute()

        # Add messages from the first page
        if 'messages' in response:
            all_messages.extend(response['messages'])

        # Keep fetching the next pages
        while 'nextPageToken' in response:
            response = service.users().messages().list(
                userId='me',
                labelIds=[label_id],
                q=query,
                pageToken=response['nextPageToken']
            ).execute()
            if 'messages' in response:
                all_messages.extend(response['messages'])

        print(f"Total messages fetched: {len(all_messages)}")
        return all_messages
    except Exception as e:
        print(f"Error fetching messages: {e}")
        return []

def get_email_body(service, message_id):
    """
    Fetch the body of the email and decode its content, handling multipart emails.
    """
    try:
        message = service.users().messages().get(userId='me', id=message_id, format='full').execute()
        payload = message.get('payload', {})
        if 'parts' in payload:
            for part in payload['parts']:
                if part['mimeType'] in ['text/plain', 'text/html']:
                    data = part['body'].get('data', '')
                    if data:
                        return base64.urlsafe_b64decode(data).decode('utf-8')
        elif 'body' in payload:
            data = payload['body'].get('data', '')
            if data:
                return base64.urlsafe_b64decode(data).decode('utf-8')
    except Exception as e:
        print(f"Error retrieving email body for message ID {message_id}: {e}")
    return None

def extract_bounced_email_from_body(email_body):
    """
    Extract bounced email address from the email body.
    """
    pattern = r"<([\w\.-]+@[\w\.-]+\.\w+)>.*delivery failed"
    match = re.search(pattern, email_body)
    return match.group(1) if match else None

def mark_email_as_read(service, message_id):
    """
    Mark an email as read by modifying its labels.
    """
    service.users().messages().modify(userId='me', id=message_id, body={'removeLabelIds': ['UNREAD']}).execute()

def fetch_bounced_emails_from_body(service, messages):
    """
    Fetch bounced emails by parsing the body of email messages.
    """
    bounced_emails = []
    for message in messages:
        message_id = message['id']
        email_body = get_email_body(service, message_id)
        if email_body:
            bounced_email = extract_bounced_email_from_body(email_body)
            if bounced_email:
                bounced_emails.append(bounced_email)
                mark_email_as_read(service, message_id)
    return bounced_emails

def save_to_excel(email_list, filename):
    """
    Save the bounced email list to an Excel file.
    """
    if not email_list:
        return
    df = pd.DataFrame(email_list, columns=['Bounced Email'])
    df.to_excel(filename, index=False)

# Main execution
if __name__ == '__main__':
    creds = authenticate_gmail()
    service = build('gmail', 'v1', credentials=creds)

    # List all labels and find the ID for the "Bounced" label
    labels = list_gmail_labels(service)
    label_id = next((label['id'] for label in labels if label['name'] == 'Bounced'), None)

    if not label_id:
        print("Error: 'Bounced' label not found.")
        exit()

    # Fetch all messages, handling pagination
    messages = fetch_all_messages(service, label_id)
    total_messages = len(messages)
    print(f"Total unread messages found: {total_messages}")

    # Process messages in batches
    for start in range(0, total_messages, BATCH_SIZE):
        end = min(start + BATCH_SIZE, total_messages)
        batch_messages = messages[start:end]
        print(f"Processing emails {start + 1} to {end}...")

        # Extract bounced email addresses
        email_list = fetch_bounced_emails_from_body(service, batch_messages)
        save_to_excel(email_list, f'bounced_emails_batch_{start + 1}_to_{end}.xlsx')

        time.sleep(2)  # Delay to avoid API limits

    print("Processing complete!")